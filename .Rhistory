#try to normalise data. by transformation using log
logfishes <- log(mass)
par(mfrow=c(1,1))
max(logfishes)
min(logfishes)
hist(logfishes,breaks = max(logfishes),min(logfishes), col = 'blue', main = 'new')
lines(seq(-2,4,0.1),length(logfishes)*dnorm(seq(-2,4,0.1),mean(logfishes),sqrt(var(logfishes))))
#wald test for normality null: normally distributed
#alternative: not normally distributed
#when p<alpha we reject null, hence data not normally distributed.
#try to normalise data. by transformation using log
logfishes <- log10(mass)
par(mfrow=c(1,1))
max(logfishes)
min(logfishes)
hist(logfishes,breaks = max(logfishes),min(logfishes), col = 'blue', main = 'new')
lines(log10(seq(0,16,0.1)),length(logfishes)*dnorm(log(seq(0,16,0.1)),mean(logfishes),sqrt(var(logfishes))))
lines(log10(seq(0,16,0.1)),length(logfishes)*dnorm(log10(seq(0,16,0.1)),mean(logfishes),sqrt(var(logfishes))))
hist(logfishes,breaks = max(logfishes),min(logfishes), col = 'blue', main = 'new')
lines(log10(seq(0,16,0.1)),length(logfishes)*dnorm(log10(seq(0,16,0.1)),mean(logfishes),sqrt(var(logfishes))))
shapiro.test(logfishes)
?log10
t.test(logfishes)
#maximum likelihood normal dist----
#the z test
par(mfrow=c(2,2))
curve(dnorm,-3,3,xlab = 'z',ylab = 'probability density',main='density')
curve(pnorm,-3,3,xlab = 'z',ylab = 'probability', main='probability')
#for density distribution, area under the curve
curve(pnorm,-3,3,xlab = 'z',ylab = 'probability', main='probability')
curve(dnorm,-3,3,xlab = 'z',ylab = 'probability density',main='density')
#maximum likelihood normal dist----
#the z test for std normal dist
par(mfrow=c(2,2))
curve(dnorm,-3,3,xlab = 'z',ylab = 'probability density',main='density')
#for density distribution, area under the curve
curve(pnorm,-3,3,xlab = 'z',ylab = 'probability', main='probability')
#for probability distribution s shaped
curve(qnorm,0.1,xlab = 'p',ylab = 'quantile (z)', main='quantiles')
#for quantile values
y <- rnorm(1000)
#1000 random numbers, mean = 0, sd = 1
hist(y,xlab = 'z',ylab = 'frequency',main = 'random numbers')
#maximum likelihood normal dist----
#the z test for std normal dist
par(mfrow=c(2,2))
curve(dnorm,-3,3,xlab = 'z',ylab = 'probability density',main='density')
#for density distribution, area under the curve
curve(pnorm,-3,3,xlab = 'z',ylab = 'probability', main='probability')
#for probability distribution s shaped
curve(qnorm,0.1,xlab = 'p',ylab = 'quantile (z)', main='quantiles')
#for quantile values
y <- rnorm(1000)
#1000 random numbers, mean = 0, sd = 1
hist(y,xlab = 'z',ylab = 'frequency',main = 'random numbers')
#maximum likelihood normal dist----
#the z test for std normal dist
par(mfrow=c(2,2))
curve(dnorm,-3,3,xlab = 'z',ylab = 'probability density',main='density')
#for density distribution, area under the curve
curve(pnorm,-3,3,xlab = 'z',ylab = 'probability', main='probability')
#for probability distribution s shaped
curve(qnorm,0.1,xlab = 'p',ylab = 'quantile (z)', main='quantiles')
#for quantile values
y <- rnorm(1000)
#1000 random numbers, mean = 0, sd = 1
hist(y,xlab = 'z',ylab = 'frequency',main = 'random numbers')
#maximum likelihood normal dist----
#the z test for std normal dist
par(mfrow=c(2,2))
curve(dnorm,-3,3,xlab = 'z',ylab = 'probability density',main='density')
#for density distribution, area under the curve
curve(pnorm,-3,3,xlab = 'z',ylab = 'probability', main='probability')
#for probability distribution s shaped
curve(qnorm,0.1,xlab = 'p',ylab = 'quantile (z)', main='quantiles')
#for quantile values
y <- rnorm(1000)
#1000 random numbers, mean = 0, sd = 1
hist(y,xlab = 'z',ylab = 'frequency',main = 'random numbers')
install.packages("tidyverse")
install.packages("ggplot2")
install.packages("MASS")
install.packages("gplots")
install.packages("parallel")
install.packages("BiocManager")
install.packages("EMMREML")
install.packages("ape")
install.packages("LDheatmap")
install.packages("scatterplot3d")
install.packages("plotly")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics")
BiocManager::install("multtest")
install.packages("devtools")
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
install.packages("compiler")
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
install.packages("nloptr")
install.packages("lme4")
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("ggplot2")
install.packages("MASS")
install.packages("gplots")
install.packages("parallel")
install.packages("BiocManager")
install.packages("EMMREML")
install.packages("ape")
install.packages("tidyverse")
install.packages("ggplot2")
install.packages("MASS")
install.packages("gplots")
install.packages("parallel")
install.packages("BiocManager")
install.packages("EMMREML")
install.packages("ape")
install.packages("LDheatmap")
install.packages("scatterplot3d")
install.packages("plotly")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocGenerics")
BiocManager::install("multtest")
install.packages("devtools")
install.packages("compiler")
install.packages("nloptr")
install.packages("lme4")
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
install.packages("compiler")
install.packages("remotes")
install.packages("remotes")
library(devtools)
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
remotes::install_github("jiabowang/GAPIT3",force=TRUE)
remotes::install_github("jiabowang/GAPIT3")
library(GAPIT3)
library('GAPIT3')
source("http://zzlab.net/GAPIT/GAPIT.library.R")
source("http://zzlab.net/GAPIT/gapit_functions.txt")
library('GAPIT3')
install.packages("tidyverse")
remotes::install_github("jiabowang/GAPIT3",force=TRUE)
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
remotes::install_github("jiabowang/GAPIT3",force=TRUE)
library('GAPIT3')
remotes::install_github("jiabowang/GAPIT3")
install.packages("lme4")
install.packages("lme4")
install.packages("nloptr")
install.packages("nloptr")
install.packages("nloptr")
devtools::install_github("jiabowang/GAPIT3",force=TRUE)
remotes::install_github("jiabowang/GAPIT3")
##chi2 test----
1-pchisq(14.3,9)
qchisq(0.95,9)
1-pf(2.85,8,12)
qt(0.975,10)
#chi2,x disb----
#mean = df
par(mfrow=c(1,2))
x <- seq(0,30,0.25)
plot(x,pchisq(x,3,7.25), type = 'l',ylab='p(x)',xlab = 'x')
plot(x,pchisq(x,5,10),type = 'l',ylab = 'p(x)',xlab = 'x')
#var = 10.2 , df =8, interval alpha2
8*10.2/qchisq(0.975,8)
8*10.2/qchisq(0.025,8)
#fisher's test----
qf(0.95,2,18)
x <- seq(0.05,4,0.05)
df2,df18
#df2,df18
plot(x,df(x,2,18),type = 'l',ylab = 'f(x)',xlab = 'x')
plot(x,df(x,6,18),type = 'l',ylab = 'f(x)',xlab = 'x')
par(mfrow=c(1,1))
df <- seq(1,30,0.1)
plot(df,qf(0.95,df,30),type = 'l',ylab = 'critical F',)
lines(df,qf(0.95,df,10),lty=2)
lines(df,qf(0.95,df,10),lty=3) #lty - line type 2 broken line
lines(df,qf(0.95,df,10),lty=15) #lty - line type 2 broken line
lines(df,qf(0.95,df,10),lty=2) #lty - line type 2 broken line
x <- seq(0.01,3,0.01)
plot(x,df(x,1,10),type = 'l',ylim = c(0,1),ylab = 'f(x)')
lines(x,df(x,2,10),lty=6,col='red')
lines(x,df(x,5,10),lty=2,col='green')
lines(x,df(x,30,10),lty=3,col='blue')
legend(2,0.9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,0,9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(0.2,0.9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,0.9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
x <- seq(0.01,3,0.01)
plot(x,df(x,1,10),type = 'l',ylim = c(0,1),ylab = 'f(x)')
lines(x,df(x,2,10),lty=6,col='red')
lines(x,df(x,5,10),lty=2,col='green')
lines(x,df(x,30,10),lty=3,col='blue')
legend(2,0.9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,2,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,2,c('1','2','5','30'),col=(1:2),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,2,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,1,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(1,1,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,1,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,0.1,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
plot(x,df(x,1,10),type = 'l',ylim = c(0,1),ylab = 'f(x)')
lines(x,df(x,2,10),lty=6,col='red')
lines(x,df(x,5,10),lty=2,col='green')
lines(x,df(x,30,10),lty=3,col='blue')
legend(2,0.1,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,0.5,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,2.9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
legend(2,0.9,c('1','2','5','30'),col=(1:4),lty=c(1,6,2,3),title = 'numerator d.f')
#students t distribution----
curve((1+x^2)^(-0.5),-3,3,ylab = 't(x)',col=red)
#students t distribution----
curve((1+x^2)^(-0.5),-3,3,ylab = 't(x)',col='red')
plot(1:30,qt(0.975,1:30),ylim=c(0,12),type='l',ylab='student
t value',xlab='d.f',col='red')
abline(h=2,lty=2,col='green')
plot(1:30,qt(0.975,1:30),ylim=c(0,12),type='l',ylab='student
t value',xlab='d.f',col='red')
abline(h=2,lty=2,col='green')
xvs <- seq(-4,4,0.01)
plot(xvs,dnorm(xvs),type='l',lty=2,ylab='prob density',xlab='deviates')
plot(xvs,dnorm(xvs),type='l',lty=26,ylab='prob density',xlab='deviates',col='red')
lines(xvs,dt(xvs,df=5),col='blue')
#two tail alpha/2 hence 0.05/2. so 0.975
qt(0.975,5)
data <- read.table('temp.txt',header = T)
attach(data)
names(data)
par(mfrom=c(2,2))
par(mfrow=c(2,2))
plot(temps)
install.packages(c("RcppArmadillo", "RcppEigen", "scales", "vctrs"))
names(data)
par(mfrow=c(2,2))
plot(temps)
boxplot(temps)
hist(temps, main='')
par(mfrow=c(1,1))
plot(temps)
boxplot(temps)
hist(temps, main='')
summary(temps)
par(mfrow=c(1,1))
qqnorm(temps)
qqline(temps,lty=2)
x <- exp(rnorm(30))
shapiro.test(x)
shapiro.test(temps)
log(temps)
par(mfrow=c(1,1))
qqnorm(log(temps))
qqline(log(temps),lty=2)
shapiro.test(log(temps))
wilcox.test(temps)
?attach
t.test(temps)
#2 sample -----
fdata <- read.table('f.test.data.txt',header = T)
attach(fdata)
names(fdata)
#assumptions variances are equal
var(gardenB)
var(gardenC)
t.test(gardenB,gardenC)
shapiro.test(gardenB)
shapiro.test(gardenC)
shapiro.test(log(gardenC))
t.test(gardenB,log(gardenC))
#t.test(gardenB,gardenC) two sample t.test
f.ratio <- var(gardenC)/var(gardenB)
f.ratio
#critical f=4.026, cal f=10.66667, reject H0.
#because critical F < calculated F
2*(1-pf(f.ratio,9,9))
#two tailed nature of the test
#shortcut
var.test(gardenB,gardenC)
#2 sample -----
fdata <- read.table('f.test.data.txt',header = T)
attach(fdata)
names(fdata)
t.test.data <- read.table('gardens.txt',header = T)
attach(t.test.data)
names(t.test.data)
ttest.data <- read.table('gardens.txt',header = T)
attach(ttest.data)
names(ttest.data)
View(t.test.data)
effect <- c(gardenA, gardenB)
label <- factor(c(rep('A',10),rep('B',10)))
boxplot(effect~label,notch=T,xlab='Garden',ylab = 'ozone',col='Red')
boxplot(effect~label,notch=F,xlab='Garden',ylab = 'ozone',col='Red')
s2A <- var(gardenA)
s2B <- var(gardenB)
qt(0.975,18)
(mean(gardenA)-mean(gardenB))/sqrt(s2A/10+s2B/10)
t.test(gardenA,gardenB)
#wilcokson----
ozone <- c(gardenA,gardenB)
label <- c(rep('A',10),rep('B',10))
combined.ranks <- rank(ozone)
wilcox.test(gardenA,gardenB)
combined.ranks
stream <- read.table('streams.txt',header = T)
attach(stream)
names(stream)
t.test(down,up)
#use paired=True
t.test(down,up,paired = TRUE)
#now gives significant pvalue
diff <- down-up
t.test(diff)
binom.test(1,9)
#binomial ----
#vec1 success f,m
#vec2 total f,m
prop.test(c(4,196),c(40,3270))
#chi-sq test----
qchisq(0.95,1)
count <- matrix(c(38,14,11,51),nrow = 2)
count
chisq.test(count)
chisq.test(count,correct = FALSE)
chisq.test(c(10,3,2,6))
chisq.test(c(10,3,26),p=c(0.2,0.2,0.3,0.3))
chisq.test(c(10,3,2,6),p=c(0.2,0.2,0.3,0.3))
die <- ceiling(runif(100,0,6))
table(die)
#more accurate
chisq.test(count,correct=F)$expected
#more accurate
chisq.test(count,correct=F)$expected
#contigency tables----
factorial(8)*factorial(12)*factorial(10)*factorial(10)/(factorial(6)*factorial(2)*factorial(4)*factorial(8)*factorial(20))
x <- as.matrix(c(6,4,2,8))
dim(x) <- c(2,2)
table <- read.table('fisher.txt', header=TRUE)
attach(table)
names(table)
head(table)
fisher.test(tree,nests)
data <- read.table('twosample.txt',header = T)
attach(data)
names(data)
plot(x,y,pch=21,col='Red',bg='orange')
plot(plot$x,plot$y,pch=21,col='Red',bg='orange')
plot(x,y,pch=21,col='Red',bg='orange')
plot(data$x,data$y,pch=21,col='Red',bg='orange')
var(x)
var(y)
cov(x,y)
cov(data$x,data$y)
var(data$x)
var(data$y)
var(data$x,data$y)
var(data$x,data$y)/sqrt(var(data$x)*var(data$y))
cor(data$x,data$y)
x <- c(2,3,3,3,4)
y <- c(2,3,2,1,2)
par(mfrow=c(1,2))
plot(x,y,xlim=c(0,8),ylim=c(0,8))
#outlier
x1 <- c(x,7)
y1 <- c(y,6)
plot(x1,y1,xlim=c(0,8),ylim=c(0,8))
abline(lm(y1~x1),col=&quot;blue&quot;)
abline(lm(y1~x1),col='blue')
reg <- lm(y1~x1)
summary(reg)
influence.measures(reg)
influence.measures(reg)$is.inf
#OR
lm.influence(reg):
#OR
lm.influence(reg)
lm(y1[-6]~x1[-6])
summary.aov(lm(y1[-6]~x1[-6]))
#OR
lm.influence(reg):lm.influence(reg)
#OR
lm.influence(reg):
lm.influence(reg)
lm(y1[-6]~x1[-6])
summary.aov(lm(y1[-6]~x1[-6]))
data <- read.table("regression.txt",header=T)
attach(data)
names(data)
model <-lm(growth~tannin)
logLik(model)
AIC(model)
influence.measures(model)
AIC(model)
influence.measures(model)
graze <- read.table("ipomopsis.txt",header=T)
attach(graze)
names(graze)
#AIC as a measure of the fit of a model
model.1 <- lm(Fruit~Grazing*Root)
model.2 <- lm(Fruit~Grazing+Root)
AIC(model.1, model.2)
#Model checking in R ----
decay <- read.table("Decay.txt",header=T)
attach(Decay)
attach(decay)
names(decay)
model <- lm(amount~time)
par(mfrow=c(2,2))
plot(model)
par(mfrow=c(1,2))
plot(model)
comp <- read.table("competition.txt",header=T)
attach(comp)
names(comp)
model <- lm(biomass~clipping)
summary.lm(model)
summary.aov(model)
means <- tapply(biomass,clipping,mean)
means
#
prodct<-read.table("productivity.txt", header=TRUE)
attach(prodct)
names(prodct)
head(prodct)
plot(prodct$x, prodct$y, pch=21, col="blue", bg="green",  xlab="Productivity", ylab="Mammal species")
cor.test(prodct$x,prodct$y)
#Scale-dependent correlations----
prodct<-read.table("productivity.txt", header=TRUE)
attach(prodct)
names(prodct)
head(prodct)
plot(prodct$x, prodct$y, pch=21, col="blue", bg="green",  xlab="Productivity", ylab="Mammal species")
cor.test(prodct$x,prodct$y)
formula<-prodct$x ~ prodct$y | prodct$f
coplot(formula, prodct,col = blue))
coplot(formula, prodct,col = blue)
coplot(formula, prodct,col = 'blue')
coplot(formula, prodct,col = 'blue')
#Bootstrap-----
data <- read.table("skewdata.txt",header=T)
attach(data)
names(data)
head(data)
sample(values,replace=T)
ms <- numeric(10000)
for (i in 1:10000){
ms[i] <- mean(sample(values,replace=T))}
quantile(ms,c(0.025,0.975))
head ms
head(ms)
mean(values)-quantile(ms,c(0.025,0.975))
1.96*sqrt(var(values)/length(values))
boot(data, statistic, R)
boot::acme
boot::data
library(boot)
boot(data, statistic, R)
#boot(data, statistic, R)
mymean <- function(values,i) mean(values[i])
#The key point is that we write mean(values[i]) not mean(values)
#Now we can run the bootstrap for 10 000 iterations
myboot <- boot(values,mymean,R=10000)
myboot
boot.ci(myboot)
#PCA----
#kmd <- read.table("kmeansdata.txt",header=T)
#Partitioning
kmd <- read.table("kmeansdata.txt",header=T)
attach(kmd)
names(kmd)
par(mfrow=c(2,2))
plot(kmd$x,kmd$y,pch=16)
plot(kmd$x,kmd$y,col=group,pch=16)
model <- kmeans(data.frame(x,y),6)
plot(kmd$x,kmd$y,col=model[[1]])
model <- kmeans(data.frame(x,y),4)
plot(kmd$x,kmd$y,col=model[[1]])
par(mfrow=c(1,1))
#PCA----
#kmd <- read.table("kmeansdata.txt",header=T)
#Partitioning
kmd <- read.table("kmeansdata.txt",header=T)
attach(kmd)
names(kmd)
par(mfrow=c(2,2))
plot(kmd$x,kmd$y,pch=16)
plot(kmd$x,kmd$y,col=group,pch=16)
model <- kmeans(data.frame(x,y),6)
plot(kmd$x,kmd$y,col=model[[1]])
model <- kmeans(data.frame(x,y),4)
plot(kmd$x,kmd$y,col=model[[1]])
par(mfrow=c(1,1))
#Hierarchical
taxa <- read.table("taxon.txt",header=T)
attach(taxa)
names(taxa)
pairs(taxa)
kmeans(taxa,4)
plot(hclust(dist(taxa)),main="")
library(MASS)
model <- lda(Taxon~.,taxa)
plot(model,col=rep(1:4,each=30))
?MASS
??MASS
?Ida
??Ida
?lda
